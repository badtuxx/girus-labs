apiVersion: v1
kind: ConfigMap
metadata:
  name: kubernetes-servicos-redes-lab
  namespace: girus
  labels:
    app: girus-lab-template
data:
  lab.yaml: |
    name: kubernetes-servicos-redes
    title: "Serviços e Redes no Kubernetes"
    description: "Aprenda como expor aplicações executando em Pods e implementar a comunicação entre os componentes da sua aplicação usando os tipos de Serviços do Kubernetes. Este laboratório guiado explorará os conceitos fundamentais de redes no Kubernetes e como eles possibilitam a comunicação interna e externa às suas aplicações."
    duration: 30m
    image: "linuxtips/girus-kind-single-node:0.1"
    tasks:
      - name: "Criando um Namespace Isolado"
        description: "Configure um namespace para isolar os recursos criados durante este laboratório, compreendendo como os namespaces proporcionam isolamento lógico no Kubernetes."
        steps:
          - "No Kubernetes, **namespaces** fornecem uma forma de segmentar um cluster em ambientes virtuais isolados. Eles são fundamentais para organizar recursos em equipes grandes, separar ambientes (dev, teste, produção) ou isolar projetos."
          - "Vamos criar um namespace dedicado para este laboratório usando o comando `kubectl create namespace`:"
          - "`kubectl create namespace servicos-lab`"
          - "Este comando instrui a API do Kubernetes a criar um novo namespace chamado 'servicos-lab'. O namespace atua como um escopo virtual dentro do cluster, onde os recursos são nomeados de forma única."
          - "Vamos verificar se o namespace foi criado corretamente listando todos os namespaces disponíveis:"
          - "`kubectl get namespaces`"
          - "Você deve ver o namespace 'servicos-lab' na lista, junto com os namespaces padrão como 'default', 'kube-system' e outros."
          - "Para facilitar nossos comandos, vamos configurar o namespace 'servicos-lab' como o namespace padrão para nossa sessão atual:"
          - "`kubectl config set-context --current --namespace=servicos-lab`"
          - "Este comando altera o contexto atual do kubectl para usar 'servicos-lab' como namespace padrão. Isso significa que não precisaremos especificar `-n servicos-lab` em cada comando que executarmos."
        tips:
          - type: "info"
            title: "Namespaces no Kubernetes"
            content: "Os namespaces fornecem isolamento lógico, não físico. Recursos como nodes e PersistentVolumes não são isolados por namespace. Alguns recursos, como Nodes, são globais e não pertencem a nenhum namespace."
          - type: "tip"
            title: "Visualizar o Namespace Atual"
            content: "O comando `kubectl config view --minify | grep namespace:` mostra o namespace atual configurado no seu contexto. Se não houver namespace configurado, o comando não mostrará nada e o 'default' será usado."
        validation:
          - command: "kubectl get ns servicos-lab -o jsonpath='{.metadata.name}' 2>/dev/null || echo 'Namespace não encontrado'"
            expectedOutput: "servicos-lab"
            errorMessage: "O namespace 'servicos-lab' não foi criado corretamente. Verifique o comando usado para criar o namespace."

      - name: "Criando uma Aplicação com Múltiplos Pods"
        description: "Implante uma aplicação web simples com frontend e backend para demonstrar como os Serviços do Kubernetes facilitam a comunicação entre componentes da aplicação."
        steps:
          - "Antes de discutirmos serviços, precisamos criar alguns Pods para expor. Em aplicações reais, geralmente temos vários componentes que precisam se comunicar entre si, como frontend e backend."
          - "**Deployments** são recursos do Kubernetes que gerenciam a criação e atualização de Pods de forma declarativa. Vamos criar um Deployment para o backend da nossa aplicação:"
          - "`kubectl create deployment backend-app --image=nginxdemos/hello:0.3 --port=80 --replicas=2 -n servicos-lab`"
          - "Este comando cria um Deployment chamado 'backend-app' com 2 réplicas (2 Pods idênticos) usando a imagem 'nginxdemos/hello:0.3', que é uma imagem Nginx com uma página personalizada. A flag `--port=80` indica que o container expõe a porta 80."
          - "Vamos verificar se o Deployment foi criado e seus Pods estão em execução:"
          - "`kubectl get deployments -n servicos-lab`"
          - "Você deve ver o Deployment 'backend-app' com 2 réplicas disponíveis."
          - "Agora vamos ver os Pods criados pelo Deployment:"
          - "`kubectl get pods -n servicos-lab`"
          - "Você deve ver 2 Pods com nomes iniciando com 'backend-app-', cada um em estado 'Running'."
          - "Agora, vamos criar outro Deployment para representar o frontend da nossa aplicação:"
          - "`kubectl create deployment frontend-app --image=nginx:alpine --port=80 -n servicos-lab`"
          - "Este comando cria um Deployment para o frontend usando a imagem 'nginx:alpine', que é uma versão leve do Nginx. Por padrão, o Kubernetes criará apenas 1 réplica quando não especificamos o número de réplicas."
          - "Vamos verificar todos os Deployments no namespace:"
          - "`kubectl get deployments -n servicos-lab`"
          - "Agora você deve ver dois Deployments: 'backend-app' com 2 réplicas e 'frontend-app' com 1 réplica."
          - "Para demonstrar como os Pods recebem IPs internos no Kubernetes, vamos listar os Pods com seus IPs:"
          - "`kubectl get pods -o wide -n servicos-lab`"
          - "A flag `-o wide` mostra informações adicionais, incluindo os IPs dos Pods. Observe que cada Pod recebe um IP único dentro da rede do cluster. Estes IPs são efêmeros - quando um Pod é recriado, ele recebe um novo IP."
        tips:
          - type: "info"
            title: "Rede de Pods no Kubernetes"
            content: "O Kubernetes atribui a cada Pod um IP único dentro do cluster. Todos os containers dentro de um Pod compartilham o mesmo IP e espaço de portas. A comunicação entre Pods é possível por padrão, mas o IP do Pod mudará se ele for recriado."
          - type: "warning"
            title: "Comunicação Direta entre Pods"
            content: "Embora seja possível se comunicar diretamente com um Pod usando seu IP, esta abordagem é desencorajada porque os IPs dos Pods são efêmeros. Em vez disso, use Serviços para descoberta e comunicação estável."
          - type: "tip"
            title: "Escalando Deployments"
            content: "Você pode alterar o número de réplicas de um Deployment com `kubectl scale deployment <nome> --replicas=<número>`. O Kubernetes criará ou removerá Pods para atingir o número desejado."
        validation:
          - command: "kubectl get pods -n servicos-lab -l app=backend-app --no-headers | wc -l"
            expectedOutput: "2"
            errorMessage: "Não foram encontrados 2 Pods para o backend-app. Verifique se o Deployment foi criado corretamente com 2 réplicas."
          - command: "kubectl get pods -n servicos-lab -l app=frontend-app --no-headers | wc -l"
            expectedOutput: "1"
            errorMessage: "Não foi encontrado 1 Pod para o frontend-app. Verifique se o Deployment foi criado corretamente."

      - name: "Criando um Serviço ClusterIP"
        description: "Crie um Serviço do tipo ClusterIP para expor o backend internamente no cluster, entendendo como os Serviços proporcionam descoberta de serviço estável e balanceamento de carga."
        steps:
          - "Agora que temos nossos Pods em execução, precisamos de uma forma de acessá-los de maneira confiável. Como mencionado, os IPs dos Pods são efêmeros e não devem ser usados diretamente."
          - "Os **Serviços** no Kubernetes proporcionam uma abstração que define um conjunto lógico de Pods e uma política para acessá-los. Eles permitem a descoberta de serviço e o balanceamento de carga entre Pods."
          - "O tipo mais básico de Serviço é o **ClusterIP**, que expõe o Serviço em um IP interno ao cluster. Este tipo é ideal para comunicação interna entre componentes da aplicação."
          - "Vamos criar um Serviço ClusterIP para o backend:"
          - "`kubectl expose deployment backend-app --name=backend-service --port=80 --target-port=80 --type=ClusterIP -n servicos-lab`"
          - "Este comando cria um Serviço chamado 'backend-service' que expõe o Deployment 'backend-app' na porta 80. Vamos entender cada parâmetro:"
          - "- `--name=backend-service`: Define o nome do Serviço"
          - "- `--port=80`: A porta em que o Serviço será exposto dentro do cluster"
          - "- `--target-port=80`: A porta do Pod alvo para a qual o tráfego será redirecionado"
          - "- `--type=ClusterIP`: O tipo de Serviço (ClusterIP é o padrão, por isso é opcional)"
          - "Vamos verificar o Serviço criado:"
          - "`kubectl get services -n servicos-lab`"
          - "Você verá o Serviço 'backend-service' com um IP interno (ClusterIP) atribuído. Este IP é estático durante o ciclo de vida do Serviço."
          - "Podemos obter mais detalhes sobre o Serviço com o comando 'describe':"
          - "`kubectl describe service backend-service -n servicos-lab`"
          - "Observe que o Serviço tem um conjunto de 'Endpoints' que são os IPs dos Pods individuais de backend. O Kubernetes mantém esta lista atualizada automaticamente à medida que Pods são criados ou removidos."
          - "Agora, vamos testar o acesso ao backend a partir de outro Pod. Vamos usar o Pod do frontend para enviar uma requisição HTTP ao backend:"
          - "`kubectl exec -it $(kubectl get pod -l app=frontend-app -o jsonpath='{.items[0].metadata.name}' -n servicos-lab) -n servicos-lab -- curl -s backend-service`"
          - "Este comando executa 'curl' dentro do Pod frontend para acessar o 'backend-service'. Observe que usamos o nome do Serviço como hostname, não seu IP. O Kubernetes configura DNS interno automaticamente para resolver nomes de Serviços."
          - "O resultado mostrará a página HTML retornada pelo backend. O Kubernetes balanceou a requisição para um dos Pods do backend."
        tips:
          - type: "info"
            title: "Tipos de Serviços"
            content: "O Kubernetes oferece vários tipos de Serviços: ClusterIP (padrão, apenas interno), NodePort (expõe em porta do Node), LoadBalancer (usa balanceador de carga externo) e ExternalName (redirecionamento DNS)."
          - type: "tip"
            title: "DNS do Kubernetes"
            content: "O Kubernetes configura automaticamente nomes DNS para Serviços. Dentro do mesmo namespace, Pods podem acessar um Serviço simplesmente pelo nome. Entre namespaces, use 'nome-servico.namespace.svc.cluster.local'."
          - type: "info"
            title: "Seletores e Endpoints"
            content: "Os Serviços usam seletores de labels para identificar quais Pods devem receber tráfego. Os Endpoints são uma lista de todos os IPs e portas dos Pods que correspondem ao seletor do Serviço."
        validation:
          - command: "kubectl get service backend-service -n servicos-lab -o jsonpath='{.spec.type}' 2>/dev/null || echo ''"
            expectedOutput: "ClusterIP"
            errorMessage: "O Serviço 'backend-service' do tipo ClusterIP não foi criado corretamente."
          - command: "kubectl get endpoints backend-service -n servicos-lab -o jsonpath='{.subsets[0].addresses}' 2>/dev/null | grep -c 'ip'"
            expectedOutput: "2"
            errorMessage: "O Serviço 'backend-service' não está associado a 2 Pods backend. Verifique se o seletor do Serviço corresponde às labels dos Pods."

      - name: "Criando um Serviço NodePort"
        description: "Exponha o frontend para acesso externo usando um Serviço NodePort, entendendo como este tipo de Serviço permite o acesso a aplicações de fora do cluster."
        steps:
          - "Até agora, nosso 'backend-service' só pode ser acessado de dentro do cluster. Para expor serviços para acesso externo, o Kubernetes oferece outros tipos de Serviços."
          - "O **NodePort** é um tipo de Serviço que expõe o Serviço em uma porta estática em cada nó do cluster. Esta porta é acessível externamente através do IP do nó."
          - "Vamos criar um Serviço NodePort para o frontend:"
          - "`kubectl expose deployment frontend-app --name=frontend-service --port=80 --target-port=80 --type=NodePort -n servicos-lab`"
          - "Este comando cria um Serviço chamado 'frontend-service' do tipo NodePort que expõe o Deployment 'frontend-app'. O Kubernetes atribuirá automaticamente uma porta aleatória na faixa 30000-32767."
          - "Vamos verificar o Serviço criado:"
          - "`kubectl get services -n servicos-lab`"
          - "Você verá o Serviço 'frontend-service' com um ClusterIP atribuído e um campo 'PORT(S)' mostrando algo como '80:3xxxx/TCP', onde 3xxxx é a porta NodePort atribuída."
          - "Vamos capturar essa porta NodePort para uso posterior:"
          - "`NODEPORT=$(kubectl get service frontend-service -n servicos-lab -o jsonpath='{.spec.ports[0].nodePort}')`"
          - "Agora podemos acessar o frontend através do IP do nó (que, em nosso ambiente Kind, é acessível via localhost) e a porta NodePort:"
          - "`curl localhost:$NODEPORT`"
          - "Você deve ver a página HTML retornada pelo frontend (Nginx). Em um cluster real, você poderia acessar este serviço através do IP de qualquer nó e a mesma porta NodePort."
          - "Para demonstrar a comunicação entre serviços, vamos modificar o frontend para atuar como um proxy reverso para o backend. Vamos criar um ConfigMap com uma configuração Nginx que encaminha requisições para '/api' para o backend:"
          - "`kubectl create configmap nginx-config --from-literal=nginx.conf='events {} http { server { listen 80; location / { root /usr/share/nginx/html; } location /api { proxy_pass http://backend-service; } } }' -n servicos-lab`"
          - "Agora, vamos atualizar o Deployment do frontend para usar esta configuração:"
          - "`kubectl set volumes deployment/frontend-app --add --name=config --mount-path=/etc/nginx/nginx.conf --sub-path=nginx.conf --configmap-name=nginx-config -n servicos-lab`"
          - "Este comando adiciona um volume ao Deployment 'frontend-app' que monta o ConfigMap 'nginx-config' no caminho '/etc/nginx/nginx.conf'. O Nginx lerá esta configuração e encaminhará requisições para '/api' para o 'backend-service'."
          - "Vamos aguardar o Pod frontend ser recriado com a nova configuração:"
          - "`kubectl rollout status deployment/frontend-app -n servicos-lab`"
          - "Agora podemos testar o serviço. Quando acessamos '/api', o frontend deve encaminhar a requisição para o backend:"
          - "`curl localhost:$NODEPORT/api`"
          - "Você deve ver a resposta do backend, demonstrando que o frontend está encaminhando requisições para o backend usando o Serviço interno 'backend-service'."
        tips:
          - type: "warning"
            title: "Limitações do NodePort"
            content: "NodePort não é geralmente recomendado para produção pois: 1) Usa portas não-padrão, 2) Expõe portas em todos os nós, mesmo que não estejam rodando o serviço, 3) Requer gerenciamento de IPs de nós, que podem mudar."
          - type: "info"
            title: "Arquitetura Comum"
            content: "Um padrão comum no Kubernetes é ter serviços de frontend expostos externamente com NodePort ou LoadBalancer, enquanto serviços de backend usam ClusterIP para comunicação interna."
          - type: "tip"
            title: "Encadeamento de Serviços"
            content: "Os Serviços podem se comunicar entre si usando seus nomes DNS. Isso permite criar arquiteturas em camadas onde cada componente se concentra em sua função específica."
        validation:
          - command: "kubectl get service frontend-service -n servicos-lab -o jsonpath='{.spec.type}' 2>/dev/null || echo ''"
            expectedOutput: "NodePort"
            errorMessage: "O Serviço 'frontend-service' do tipo NodePort não foi criado corretamente."
          - command: "NODEPORT=$(kubectl get service frontend-service -n servicos-lab -o jsonpath='{.spec.ports[0].nodePort}' 2>/dev/null || echo ''); curl -s localhost:$NODEPORT/api | grep -i 'nginx' || echo 'fail'"
            expectedOutput: "nginx"
            errorMessage: "Não foi possível acessar o backend através do frontend. Verifique a configuração do proxy reverso."

      - name: "Limpeza dos Recursos"
        description: "Remova todos os recursos criados durante o laboratório, entendendo como o Kubernetes gerencia o ciclo de vida dos recursos."
        steps:
          - "Depois de explorar os conceitos de Serviços e Redes no Kubernetes, vamos limpar todos os recursos criados para manter o cluster organizado."
          - "No Kubernetes, a exclusão de recursos pode ser feita de várias maneiras. Podemos excluir recursos individualmente ou excluir o namespace, que remove todos os recursos dentro dele."
          - "Vamos listar todos os recursos criados neste laboratório:"
          - "`kubectl get all -n servicos-lab`"
          - "O comando `kubectl get all` mostra a maioria dos recursos do Kubernetes, incluindo Pods, Serviços, Deployments, etc., mas não todos (por exemplo, não mostra ConfigMaps)."
          - "Vamos começar excluindo os Serviços:"
          - "`kubectl delete service frontend-service backend-service -n servicos-lab`"
          - "Este comando exclui os dois Serviços que criamos. Observe que a exclusão de um Serviço não afeta os Pods subjacentes - eles continuam em execução."
          - "Agora, vamos excluir os Deployments:"
          - "`kubectl delete deployment frontend-app backend-app -n servicos-lab`"
          - "Quando excluímos um Deployment, o Kubernetes exclui automaticamente todos os Pods gerenciados por ele. Isso demonstra o conceito de propriedade no Kubernetes - quando um recurso de 'pai' é excluído, seus 'filhos' também são excluídos."
          - "Vamos verificar se os Pods foram removidos:"
          - "`kubectl get pods -n servicos-lab`"
          - "Não deveria haver mais Pods listados."
          - "Agora, vamos excluir o ConfigMap:"
          - "`kubectl delete configmap nginx-config -n servicos-lab`"
          - "Finalmente, vamos excluir o namespace, o que removeria todos os recursos restantes nele (caso tivéssemos esquecido algum):"
          - "`kubectl delete namespace servicos-lab`"
          - "Esta é uma forma eficiente de limpar todos os recursos de um projeto ou experimento de uma só vez. No entanto, tenha cuidado ao usar este método em ambientes compartilhados ou de produção."
          - "Vamos verificar se o namespace foi removido:"
          - "`kubectl get namespace servicos-lab || echo 'Namespace removido com sucesso'`"
          - "Você deve ver a mensagem 'Namespace removido com sucesso', indicando que o namespace não existe mais."
        tips:
          - type: "warning"
            title: "Exclusão de Namespaces"
            content: "A exclusão de um namespace é uma operação destrutiva que não pode ser desfeita. Todos os recursos no namespace serão permanentemente removidos. Use com cautela em ambientes compartilhados ou de produção."
          - type: "info"
            title: "Cascata de Exclusão"
            content: "O Kubernetes usa o conceito de 'propriedade' para gerenciar a exclusão em cascata. Quando um recurso 'pai' (como um Deployment) é excluído, todos os recursos 'filhos' (como os Pods) também são excluídos automaticamente."
          - type: "tip"
            title: "Verificação Antes da Exclusão"
            content: "Antes de excluir recursos, especialmente em produção, use `kubectl get <recurso> -o yaml` ou `kubectl describe <recurso>` para verificar se está excluindo os recursos corretos."
        validation:
          - command: "kubectl get namespace servicos-lab 2>/dev/null || echo 'Namespace removido com sucesso'"
            expectedOutput: "Namespace removido com sucesso"
            errorMessage: "O namespace 'servicos-lab' não foi removido corretamente. Verifique se você executou 'kubectl delete namespace servicos-lab'."
