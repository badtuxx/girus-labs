apiVersion: v1
kind: ConfigMap
metadata:
  name: docker-gerenciamento-containers-lab
  namespace: girus
  labels:
    app: girus-lab-template
data:
  lab.yaml: |
    name: docker-gerenciamento-containers
    title: "Gerenciamento de Containers Docker"
    description: "Domine as técnicas de gerenciamento do ciclo de vida dos containers Docker, aprendendo a monitorar recursos, gerenciar logs e administrar múltiplos containers de forma eficiente. Este laboratório guiado explora os comandos fundamentais para o monitoramento e administração efetiva de containers em ambientes reais."
    duration: 30m
    image: "linuxtips/girus-devops:0.1"
    privileged: true # Acesso ao Docker daemon
    tasks:
      - name: "Inspecionando Containers"
        description: "Aprenda a coletar informações detalhadas sobre containers em execução, entendendo como inspecionar metadados, configurações e estado em tempo real."
        steps:
          - "O comando `docker inspect` é uma ferramenta poderosa para obter informações detalhadas sobre os objetos Docker. Vamos explorar como usar este comando para obter insights sobre containers em execução."
          - "Primeiro, vamos criar um container simples para inspecionar. Usaremos a imagem Alpine, que é uma distribuição Linux muito leve, executando-a em background:"
          - "`docker run -d --name container-teste alpine sleep 1000`"
          - "Este comando cria um container chamado 'container-teste' baseado na imagem Alpine e executa o comando 'sleep 1000', que mantém o container em execução por 1000 segundos. A flag `-d` executa o container em modo detached (background)."
          - "Agora, vamos usar o comando `docker inspect` para obter informações detalhadas sobre este container:"
          - "`docker inspect container-teste`"
          - "Este comando retorna um objeto JSON detalhado contendo todas as informações sobre o container, incluindo:"
          - "- ID e nome do container"
          - "- Estado atual (running, paused, exited, etc.)"
          - "- Configurações de rede (IP, portas, etc.)"
          - "- Volumes montados"
          - "- Configurações de ambiente"
          - "- Limites de recursos"
          - "- Metadados do sistema de arquivos"
          - "Como o JSON completo é muito extenso, podemos usar filtros para extrair informações específicas. Por exemplo, para obter apenas o IP do container:"
          - "`docker inspect -f '{{.NetworkSettings.IPAddress}}' container-teste`"
          - "A flag `-f` ou `--format` permite usar Go templates para filtrar e formatar a saída. O template `{{.NetworkSettings.IPAddress}}` extrai apenas o endereço IP do container."
          - "Vamos extrair também o estado atual do container:"
          - "`docker inspect -f '{{.State.Status}}' container-teste`"
          - "E o ID da imagem que o container está usando:"
          - "`docker inspect -f '{{.Image}}' container-teste`"
          - "Este é o ID sha256 completo da imagem, que podemos verificar com:"
          - "`docker inspect -f '{{.Config.Image}}' container-teste`"
          - "Que retorna o nome da imagem como usamos no comando 'run'."
          - "Vamos criar mais um container para fins de comparação:"
          - "`docker run -d --name container-web -p 8080:80 nginx:alpine`"
          - "Este comando cria um container executando Nginx com a porta 80 do container mapeada para a porta 8080 do host. Agora podemos comparar as configurações de rede de ambos os containers:"
          - "`docker inspect -f 'Nome: {{.Name}}, IP: {{.NetworkSettings.IPAddress}}, Portas: {{.NetworkSettings.Ports}}' container-teste container-web`"
          - "Observe como podemos inspecionar múltiplos containers de uma vez e como o container Nginx tem configurações de porta diferentes."
        tips:
          - type: "tip"
            title: "Filtros Comuns para Inspect"
            content: "Alguns filtros úteis são: `{{.State.Status}}` (estado atual), `{{.NetworkSettings.IPAddress}}` (IP), `{{.Config.Cmd}}` (comando de execução), `{{.HostConfig.RestartPolicy}}` (política de reinicialização), `{{.Mounts}}` (volumes montados)."
          - type: "info"
            title: "Formato JSON vs Go Templates"
            content: "Se preferir trabalhar com o JSON completo para processamento posterior, use `docker inspect container-teste | jq .` (se tiver o utilitário jq instalado) ou redirecione para um arquivo: `docker inspect container-teste > info.json`."
          - type: "warning"
            title: "Inspeção de Containers Parados"
            content: "Você pode inspecionar containers mesmo depois que eles foram parados, o que é útil para depuração. No entanto, algumas informações, como estatísticas de uso de recursos, não estarão disponíveis para containers parados."
        validation:
          - command: "docker inspect container-teste -f '{{.State.Status}}' 2>/dev/null || echo 'container não encontrado'"
            expectedOutput: "running"
            errorMessage: "O container 'container-teste' não está em execução ou não foi criado corretamente. Verifique o comando 'docker run'."

      - name: "Monitorando Uso de Recursos"
        description: "Aprenda a monitorar a utilização de CPU, memória e rede dos containers, compreendendo como identificar problemas de desempenho e otimizar recursos."
        steps:
          - "O monitoramento do uso de recursos é crucial para manter seus containers funcionando de maneira eficiente. O Docker fornece ferramentas para visualizar o uso de CPU, memória, rede e outros recursos em tempo real."
          - "O principal comando para monitoramento de recursos é o `docker stats`. Vamos usá-lo para ver as estatísticas de nossos containers em execução:"
          - "`docker stats --no-stream`"
          - "A flag `--no-stream` mostra um único snapshot das estatísticas em vez de uma atualização contínua, que é o comportamento padrão. A saída inclui:"
          - "- CONTAINER ID/NAME: Identificador e nome do container"
          - "- CPU %: Porcentagem de CPU usada pelo container"
          - "- MEM USAGE/LIMIT: Uso de memória atual e limite máximo"
          - "- MEM %: Porcentagem de memória usada em relação ao limite"
          - "- NET I/O: Dados de rede recebidos e enviados"
          - "- BLOCK I/O: Operações de leitura/escrita em disco"
          - "- PIDS: Número de processos em execução no container"
          - "Podemos especificar containers específicos para monitorar:"
          - "`docker stats --no-stream container-teste container-web`"
          - "Agora, vamos criar um container que consome mais recursos para observar o impacto nas estatísticas:"
          - "`docker run -d --name stress-test alpine sh -c 'while true; do echo \"CPU load\"; done'`"
          - "Este container executa um loop infinito, gerando alguma carga na CPU. Vamos ver as estatísticas novamente:"
          - "`docker stats --no-stream`"
          - "Você deve ver que o container 'stress-test' está consumindo mais CPU que os outros."
          - "Para um monitoramento mais detalhado, podemos usar o comando `docker top` para ver os processos em execução dentro de um container específico:"
          - "`docker top container-web`"
          - "Este comando mostra uma lista dos processos em execução dentro do container 'container-web', similar ao comando 'top' do Linux, incluindo PID, usuário, consumo de recursos e comando."
          - "Vamos verificar os processos no container de stress test:"
          - "`docker top stress-test`"
          - "Você verá o processo do shell e o loop 'echo' consumindo recursos."
          - "Para casos em que precisamos de informações mais específicas sobre um container, podemos usar o comando `docker container ls` com formatação personalizada:"
          - "`docker container ls --format '{{.Names}}: {{.Status}} - {{.Ports}}' -a`"
          - "A flag `-a` inclui todos os containers, mesmo os parados, e o formato personalizado mostra o nome, status e portas expostas de cada container."
        tips:
          - type: "info"
            title: "Limites de Recursos"
            content: "Em ambientes de produção, é recomendável definir limites de recursos nos containers usando flags como `--memory` e `--cpu` no comando `docker run`. Por exemplo: `docker run --memory=512m --cpus=0.5 [imagem]` limita o container a 512MB de memória e 50% de uma CPU."
          - type: "tip"
            title: "Monitoramento Contínuo"
            content: "Para monitoramento contínuo, execute `docker stats` sem a flag `--no-stream`. Para sair do modo contínuo, pressione Ctrl+C. Em sistemas de produção, considere ferramentas como Prometheus e Grafana para monitoramento mais avançado."
          - type: "warning"
            title: "Interpretando Estatísticas"
            content: "O uso de CPU é relativo ao total de recursos do host. Por exemplo, 100% não significa necessariamente que o container está usando 100% da CPU do host, mas sim 100% do que foi alocado ao container (que pode ser limitado)."
        validation:
          - command: "docker stats --no-stream stress-test 2>/dev/null | grep stress-test || echo 'container não encontrado'"
            expectedOutput: "stress-test"
            errorMessage: "O container 'stress-test' não está em execução ou não foi criado corretamente. Verifique o comando 'docker run'."

      - name: "Gerenciando Logs"
        description: "Acesse e gerencie logs de containers para diagnóstico e solução de problemas, compreendendo as diferentes opções de logging do Docker."
        steps:
          - "Os logs são uma parte crucial do diagnóstico e solução de problemas em containers. O Docker captura a saída padrão (stdout) e erro padrão (stderr) de cada container, permitindo acessar esses logs facilmente."
          - "Vamos criar um container que gera logs para demonstrar as capacidades de logging do Docker:"
          - "`docker run -d --name log-generator alpine sh -c 'while true; do echo \"$(date): Log entry\"; sleep 2; done'`"
          - "Este container cria uma nova entrada de log a cada 2 segundos, incluindo a data e hora atual."
          - "O comando básico para ver logs é `docker logs`:"
          - "`docker logs log-generator`"
          - "Este comando mostra todos os logs do container 'log-generator'. Por padrão, o Docker armazena todos os logs desde o início da execução do container."
          - "Para ver apenas as entradas mais recentes, podemos usar a flag `--tail`:"
          - "`docker logs --tail 5 log-generator`"
          - "Isso mostra apenas as 5 entradas mais recentes do log, o que é útil para containers com muitos logs."
          - "Para acompanhar os logs em tempo real (similar ao comando 'tail -f'), usamos a flag `-f` ou `--follow`:"
          - "`docker logs -f log-generator`"
          - "Este comando continua exibindo novas entradas de log à medida que são geradas. Pressione Ctrl+C para sair do modo de acompanhamento."
          - "Também podemos limitar os logs por tempo, mostrando apenas entradas após um determinado timestamp:"
          - "`docker logs --since 1m log-generator`"
          - "Este comando mostra apenas os logs dos últimos 1 minuto. Podemos usar unidades como m (minutos), h (horas), etc."
          - "Da mesma forma, podemos mostrar logs até um determinado momento:"
          - "`docker logs --until 30s log-generator`"
          - "Isso mostra logs gerados até os últimos 30 segundos."
          - "Se quisermos adicionar timestamps aos logs (útil para debugging):"
          - "`docker logs --timestamps log-generator`"
          - "Isso adiciona o timestamp do Docker a cada entrada de log, permitindo correlacionar eventos."
          - "Em aplicações reais, muitas vezes queremos redirecionar logs para análise ou armazenamento. Podemos fazer isso facilmente:"
          - "`docker logs log-generator > container_logs.txt`"
          - "Este comando salva todos os logs do container em um arquivo local chamado 'container_logs.txt'."
          - "Para containers que geram muitos logs, podemos configurar a rotação de logs. Isso é feito no daemon do Docker, mas podemos verificar a configuração atual com:"
          - "`docker info | grep 'Logging Driver'`"
          - "O driver de logging padrão é geralmente 'json-file', mas o Docker suporta vários drivers como syslog, journald, splunk, etc., para integração com sistemas de log centralizados."
        tips:
          - type: "info"
            title: "Drivers de Logging"
            content: "O Docker suporta vários drivers de logging que podem ser configurados com a flag `--log-driver` durante a criação do container. Exemplos incluem 'json-file' (padrão), 'syslog', 'journald', 'fluentd', 'awslogs', 'splunk', etc."
          - type: "warning"
            title: "Rotação de Logs"
            content: "Em ambientes de produção, configure a rotação de logs para evitar que os logs consumam todo o espaço em disco. Isso pode ser feito por container com as opções `--log-opt max-size=10m --log-opt max-file=3`, limitando cada arquivo a 10MB e mantendo no máximo 3 arquivos."
          - type: "tip"
            title: "Filtragem de Logs"
            content: "Combine `docker logs` com ferramentas como `grep` para filtrar entradas específicas. Por exemplo: `docker logs log-generator | grep error` mostra apenas entradas contendo a palavra 'error'."
        validation:
          - command: "docker logs --tail 1 log-generator 2>/dev/null | grep 'Log entry' || echo 'container não encontrado'"
            expectedOutput: "Log entry"
            errorMessage: "O container 'log-generator' não está gerando logs corretamente. Verifique o comando 'docker run'."

      - name: "Limpeza e Remoção"
        description: "Aprenda a gerenciar o ciclo de vida completo dos containers, compreendendo como parar, iniciar e remover containers de forma eficiente e segura."
        steps:
          - "Após trabalhar com containers, é importante saber como gerenciar seu ciclo de vida completo, incluindo como pará-los e removê-los adequadamente para liberar recursos."
          - "**Parando Containers**"
          - "Vamos começar parando alguns dos containers que criamos. O comando `docker stop` envia um sinal SIGTERM ao processo principal do container, dando a ele tempo para desligar graciosamente:"
          - "`docker stop container-teste`"
          - "Se o container não parar após 10 segundos (tempo padrão), o Docker envia um sinal SIGKILL forçando o encerramento."
          - "Podemos parar múltiplos containers de uma vez especificando vários nomes ou IDs:"
          - "`docker stop container-web stress-test`"
          - "Para verificar o status dos containers, usamos:"
          - "`docker ps -a`"
          - "A flag `-a` mostra todos os containers, incluindo os parados. Você deve ver os containers que paramos com o status 'Exited'."
          - "**Iniciando Containers Parados**"
          - "Para reiniciar um container parado, sem criar um novo:"
          - "`docker start container-web`"
          - "Isto inicia o container com as mesmas configurações com que foi originalmente criado."
          - "Podemos verificar se o container está rodando:"
          - "`docker ps`"
          - "Agora o container 'container-web' deve aparecer como 'Up'."
          - "**Pausando e Despausando Containers**"
          - "O Docker também permite pausar e despausar containers sem pará-los completamente:"
          - "`docker pause container-web`"
          - "Isto suspende todos os processos no container, mas mantém seu estado na memória."
          - "Para verificar, podemos usar:"
          - "`docker ps`"
          - "O container 'container-web' deve aparecer como 'Paused'."
          - "Para despausar:"
          - "`docker unpause container-web`"
          - "**Removendo Containers**"
          - "Quando não precisamos mais de um container, podemos removê-lo. Um container deve estar parado antes de ser removido:"
          - "`docker stop log-generator`"
          - "`docker rm log-generator`"
          - "Para verificar a remoção:"
          - "`docker ps -a | grep log-generator || echo 'Container removido com sucesso'`"
          - "Se não houver saída do grep, você verá 'Container removido com sucesso'."
          - "Para remover um container assim que ele parar (útil para containers temporários), podemos usar a flag `--rm` durante a criação:"
          - "`docker run --rm alpine echo 'Este container será removido automaticamente após completar'`"
          - "**Remoção Forçada**"
          - "Para parar e remover um container em uma única operação, podemos usar a flag `-f` (force):"
          - "`docker rm -f container-web`"
          - "Isto é equivalente a `docker stop` seguido de `docker rm`, mas deve ser usado com cuidado em ambientes de produção."
          - "**Removendo Todos os Containers**"
          - "Para remover todos os containers parados:"
          - "`docker container prune -f`"
          - "A flag `-f` pula a confirmação, mas em ambientes de produção, você pode querer remover essa flag para revisar o que será removido."
          - "Ou, para parar e remover todos os containers (cuidado!):"
          - "`docker stop $(docker ps -q) && docker rm $(docker ps -aq)`"
          - "Isto para todos os containers em execução e depois remove todos os containers."
        tips:
          - type: "warning"
            title: "Remoção de Containers com Volumes"
            content: "Por padrão, volumes anônimos associados a containers não são removidos quando o container é removido. Para remover também os volumes associados, use a flag `-v`: `docker rm -v container-name`."
          - type: "info"
            title: "Ciclo de Vida dos Containers"
            content: "O ciclo de vida típico de um container é: criado (`docker create`) -> iniciado (`docker start`) -> em execução -> parado (`docker stop`) -> removido (`docker rm`). Compreender este ciclo ajuda a gerenciar recursos de forma eficiente."
          - type: "tip"
            title: "Nomeando Containers"
            content: "Sempre use a flag `--name` ao criar containers importantes para facilitar a referência posteriormente. Nomes são mais fáceis de lembrar do que IDs. Para containers temporários ou em automações, você pode omitir o nome para que o Docker gere um automaticamente."
        validation:
          - command: "docker ps -a --filter 'name=container-teste' --filter 'status=exited' --format '{{.Names}}' | grep container-teste || echo 'Container não parado ou não existe'"
            expectedOutput: "container-teste"
            errorMessage: "O container 'container-teste' não foi parado corretamente. Verifique o comando 'docker stop'."
          - command: "docker ps -a --filter 'name=container-web' 2>/dev/null || echo 'Container removido com sucesso'"
            expectedOutput: "Container removido com sucesso"
            errorMessage: "O container 'container-web' não foi removido corretamente. Verifique o comando 'docker rm -f'."
