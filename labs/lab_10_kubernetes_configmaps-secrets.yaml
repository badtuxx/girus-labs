apiVersion: v1
kind: ConfigMap
metadata:
  name: kubernetes-configmaps-secrets-lab
  namespace: girus
  labels:
    app: girus-lab-template
data:
  lab.yaml: |
    name: kubernetes-configmaps-secrets
    title: "ConfigMaps e Secrets no Kubernetes"
    description: "Aprenda a gerenciar configurações e dados sensíveis no Kubernetes usando ConfigMaps e Secrets. Este laboratório guiado apresenta conceitos e práticas essenciais para armazenar, gerenciar e injetar configurações e informações confidenciais nos seus aplicativos containerizados, garantindo maior segurança e flexibilidade na administração de ambientes Kubernetes."
    duration: 30m
    image: "linuxtips/girus-devops:0.1"
    tasks:
      - name: "Fundamentos de ConfigMaps"
        description: "Entenda o conceito e aprenda a criar e utilizar ConfigMaps para gerenciar configurações no Kubernetes"
        steps:
          - "**O que são ConfigMaps?**"
          - "ConfigMaps são recursos do Kubernetes utilizados para armazenar dados não confidenciais em formato chave-valor. Eles separam as configurações do código da aplicação, possibilitando maior portabilidade e facilitando a manutenção do código."
          - "**Principais características:**"
          - "- Armazenam dados em formato texto simples (não criptografados)"
          - "- Podem conter valores individuais, partes de configuração ou arquivos inteiros"
          - "- São referenciados por Pods e outros objetos do Kubernetes"
          - "- Facilitam o princípio da 'configuração como código'"
          - "- Permitem alteração de configurações sem recompilar aplicações"
          - "**Criando um ConfigMap simples**"
          - "Vamos criar um ConfigMap usando o comando `kubectl create configmap`:"
          - "`kubectl create configmap app-config --from-literal=APP_COLOR=blue --from-literal=APP_MODE=prod`"
          - "Este comando cria um ConfigMap chamado 'app-config' com duas variáveis: APP_COLOR=blue e APP_MODE=prod."
          - "**Verificando o ConfigMap criado**"
          - "Visualize o ConfigMap que acabamos de criar:"
          - "`kubectl get configmap app-config`"
          - "Para ver os detalhes completos do ConfigMap:"
          - "`kubectl describe configmap app-config`"
          - "**Criando ConfigMap a partir de um arquivo**"
          - "Crie um arquivo de configuração com múltiplas linhas:"
          - "`echo -e \"log_level=info\\nbackend.url=api.example.com\\nallow_redirects=true\" > config.properties`"
          - "Crie um ConfigMap a partir deste arquivo:"
          - "`kubectl create configmap app-config-file --from-file=config.properties`"
          - "Verifique a criação:"
          - "`kubectl describe configmap app-config-file`"
          - "**Criando ConfigMap de forma declarativa (YAML)**"
          - "Os ConfigMaps também podem ser criados usando arquivos YAML. Crie um arquivo chamado `database-config.yaml` com o seguinte conteúdo:"
          - "`vi database-config.yaml`"
          - "```yaml"
          - "apiVersion: v1"
          - "kind: ConfigMap"
          - "metadata:"
          - "  name: database-config"
          - "data:"
          - "  database.url: \"mysql://db.example.com:3306/mydb\""
          - "  database.user: \"app_user\""
          - "  config.file: |"
          - "    # Arquivo de configuração multi-linha"
          - "    retry.attempts=3"
          - "    timeout.connection=5000"
          - "    timeout.read=3000"
          - "```"
          - "Aplique o arquivo YAML:"
          - "`kubectl apply -f database-config.yaml`"
          - "Verifique o ConfigMap criado:"
          - "`kubectl get configmap database-config -o yaml`"
        tips:
          - type: "info"
            title: "Tamanho dos ConfigMaps"
            content: "Os ConfigMaps têm um limite de tamanho de 1MB. Para configurações maiores, considere armazenar o arquivo em um volume ou serviço externo."
          - type: "warning"
            title: "Dados Sensíveis"
            content: "Nunca armazene informações sensíveis (senhas, tokens, chaves privadas) em ConfigMaps. Para dados sensíveis, use Secrets."
          - type: "tip"
            title: "Nomeação de Chaves"
            content: "Use um esquema de nomeação consistente para as chaves nos ConfigMaps para facilitar a organização e a busca de configurações específicas."
        validation:
          - command: "kubectl get configmap app-config -o jsonpath='{.data.APP_COLOR}' | grep -q blue && echo 'ok'"
            expectedOutput: "ok"
            errorMessage: "O ConfigMap app-config não foi criado corretamente com APP_COLOR=blue"
          - command: "kubectl get configmap database-config -o jsonpath='{.data.database\\.url}' | grep -q mysql && echo 'ok'"
            expectedOutput: "ok"
            errorMessage: "O ConfigMap database-config não foi criado corretamente"

      - name: "Utilizando ConfigMaps em Pods"
        description: "Aprenda diferentes formas de injetar configurações de ConfigMaps em seus Pods"
        steps:
          - "**Métodos de Uso de ConfigMaps em Pods**"
          - "Existem quatro maneiras principais de usar ConfigMaps para configurar containers em um Pod:"
          - "1. Variáveis de ambiente a partir de valores individuais"
          - "2. Variáveis de ambiente a partir de múltiplos valores (envFrom)"
          - "3. Arquivos em volumes"
          - "4. Argumentos de linha de comando"
          - "Vamos explorar cada uma delas."
          - "**1. Variáveis de Ambiente Individuais**"
          - "Crie um arquivo YAML para um Pod que usa valores do ConfigMap como variáveis de ambiente:"
          - "`vi pod-env-var.yaml`"
          - "```yaml"
          - "apiVersion: v1"
          - "kind: Pod"
          - "metadata:"
          - "  name: config-env-pod"
          - "spec:"
          - "  containers:"
          - "  - name: app-container"
          - "    image: busybox"
          - "    command: ['sh', '-c', 'echo $(APP_COLOR) $(APP_MODE) && sleep 3600']"
          - "    env:"
          - "    - name: APP_COLOR"
          - "      valueFrom:"
          - "        configMapKeyRef:"
          - "          name: app-config"
          - "          key: APP_COLOR"
          - "    - name: APP_MODE"
          - "      valueFrom:"
          - "        configMapKeyRef:"
          - "          name: app-config"
          - "          key: APP_MODE"
          - "```"
          - "Aplique o arquivo YAML:"
          - "`kubectl apply -f pod-env-var.yaml`"
          - "Verifique se o Pod está funcionando e usando os valores do ConfigMap:"
          - "`kubectl logs config-env-pod`"
          - "**2. Todas as Variáveis de um ConfigMap (envFrom)**"
          - "Crie um Pod que importa todas as variáveis de um ConfigMap:"
          - "`vi pod-envfrom.yaml`"
          - "```yaml"
          - "apiVersion: v1"
          - "kind: Pod"
          - "metadata:"
          - "  name: config-envfrom-pod"
          - "spec:"
          - "  containers:"
          - "  - name: app-container"
          - "    image: busybox"
          - "    command: ['sh', '-c', 'echo $(APP_COLOR) $(APP_MODE) && sleep 3600']"
          - "    envFrom:"
          - "    - configMapRef:"
          - "        name: app-config"
          - "```"
          - "Aplique o arquivo YAML:"
          - "`kubectl apply -f pod-envfrom.yaml`"
          - "Verifique os logs:"
          - "`kubectl logs config-envfrom-pod`"
          - "**3. Montando ConfigMaps como Volumes**"
          - "Crie um Pod que monta um ConfigMap como um volume:"
          - "`vi pod-volume.yaml`"
          - "```yaml"
          - "apiVersion: v1"
          - "kind: Pod"
          - "metadata:"
          - "  name: config-volume-pod"
          - "spec:"
          - "  containers:"
          - "  - name: app-container"
          - "    image: busybox"
          - "    command: ['sh', '-c', 'cat /config/config.properties && sleep 3600']"
          - "    volumeMounts:"
          - "    - name: config-volume"
          - "      mountPath: /config"
          - "  volumes:"
          - "  - name: config-volume"
          - "    configMap:"
          - "      name: app-config-file"
          - "```"
          - "Aplique o arquivo YAML:"
          - "`kubectl apply -f pod-volume.yaml`"
          - "Verifique se o arquivo de configuração está disponível dentro do container:"
          - "`kubectl logs config-volume-pod`"
          - "Para acessar o container e explorar os arquivos montados:"
          - "`kubectl exec -it config-volume-pod -- sh`"
          - "Dentro do container, examine o diretório de configuração:"
          - "`ls -la /config`"
          - "`cat /config/config.properties`"
          - "Digite `exit` para sair do container."
        tips:
          - type: "info"
            title: "Atualizações de ConfigMaps"
            content: "Quando um ConfigMap é atualizado, as variáveis de ambiente não são atualizadas automaticamente em Pods existentes. No entanto, arquivos montados como volumes são atualizados periodicamente (pode levar alguns minutos)."
          - type: "warning"
            title: "Dependências de Inicialização"
            content: "Se um Pod depende de um ConfigMap para inicialização, use 'initContainers' para garantir que o ConfigMap esteja disponível antes do container principal iniciar."
          - type: "tip"
            title: "Valores Padrão"
            content: "Sempre defina valores padrão para suas configurações no código da aplicação para garantir que ela inicie mesmo se o ConfigMap não estiver disponível ou se alguma chave estiver faltando."
        validation:
          - command: "kubectl logs config-env-pod | grep -q blue && echo 'ok'"
            expectedOutput: "ok"
            errorMessage: "O Pod config-env-pod não está usando corretamente as variáveis de ambiente do ConfigMap"
          - command: "kubectl get pod config-volume-pod -o jsonpath='{.spec.volumes[0].configMap.name}' | grep -q app-config-file && echo 'ok'"
            expectedOutput: "ok"
            errorMessage: "O Pod config-volume-pod não está configurado corretamente com o volume do ConfigMap"

      - name: "Trabalhando com Secrets"
        description: "Aprenda a criar e gerenciar informações sensíveis usando Secrets do Kubernetes"
        steps:
          - "**O que são Secrets?**"
          - "Secrets são objetos do Kubernetes similares aos ConfigMaps, mas projetados especificamente para armazenar informações sensíveis como senhas, tokens OAuth, chaves SSH e outros dados que não devem ser armazenados em texto simples."
          - "**Principais características:**"
          - "- Armazenam dados em formato codificado em base64 (não criptografado)"
          - "- Limitados a 1MB de tamanho"
          - "- Podem ser montados como arquivos ou expostos como variáveis de ambiente"
          - "- São armazenados no etcd do Kubernetes"
          - "- Possuem controles de acesso mais restritivos que os ConfigMaps"
          - "**Tipos de Secrets:**"
          - "- **Opaque**: tipo padrão, para dados arbitrários"
          - "- **kubernetes.io/service-account-token**: para tokens de contas de serviço"
          - "- **kubernetes.io/dockerconfigjson**: para autenticação em registros Docker"
          - "- **kubernetes.io/tls**: para certificados TLS e chaves privadas"
          - "- **bootstrap.kubernetes.io/token**: para tokens de bootstrap de nós"
          - "**Criando um Secret genérico**"
          - "Vamos criar um Secret para armazenar credenciais de banco de dados:"
          - "`kubectl create secret generic db-credentials --from-literal=username=dbuser --from-literal=password=S3cr3t!`"
          - "Verifique o Secret criado:"
          - "`kubectl get secret db-credentials`"
          - "`kubectl describe secret db-credentials`"
          - "Observe que o comando `describe` mostra os nomes das chaves, mas não seus valores."
          - "Para ver os valores codificados em base64:"
          - "`kubectl get secret db-credentials -o yaml`"
          - "Veja como os valores estão codificados em base64. Para decodificar:"
          - "`kubectl get secret db-credentials -o jsonpath='{.data.username}' | base64 --decode`"
          - "`kubectl get secret db-credentials -o jsonpath='{.data.password}' | base64 --decode`"
          - "**Criando Secret a partir de arquivos**"
          - "Crie arquivos contendo informações sensíveis:"
          - "`echo -n 'dbuser' > username.txt`"
          - "`echo -n 'S3cr3t!' > password.txt`"
          - "Crie um Secret a partir desses arquivos:"
          - "`kubectl create secret generic db-credentials-files --from-file=username=username.txt --from-file=password=password.txt`"
          - "Verifique o Secret:"
          - "`kubectl describe secret db-credentials-files`"
          - "**Criando Secret de forma declarativa (YAML)**"
          - "Ao criar Secrets em arquivos YAML, os valores precisam estar codificados em base64:"
          - "`echo -n 'admin-token-value' | base64`"
          - "Crie um arquivo para o Secret:"
          - "`vi api-token.yaml`"
          - "```yaml"
          - "apiVersion: v1"
          - "kind: Secret"
          - "metadata:"
          - "  name: api-token"
          - "type: Opaque"
          - "data:"
          - "  token: $(echo -n 'admin-token-value' | base64)"
          - "```"
          - "Aplique o arquivo YAML:"
          - "`kubectl apply -f api-token.yaml`"
          - "Verifique o Secret:"
          - "`kubectl get secret api-token -o yaml`"
        tips:
          - type: "warning"
            title: "Segurança de Secrets"
            content: "Os Secrets no Kubernetes são codificados em base64, mas NÃO são criptografados por padrão. Para maior segurança, configure a criptografia em repouso no etcd ou use soluções como HashiCorp Vault ou AWS Secret Manager integrados com Kubernetes."
          - type: "info"
            title: "Melhores Práticas"
            content: "Nunca armazene Secrets em controle de versão. Use ferramentas como Sealed Secrets, SOPS ou integrações com gerenciadores de segredos externos para gerenciar Secrets em ambientes GitOps."
          - type: "tip"
            title: "Rotação de Secrets"
            content: "Implemente um processo para rotação regular de credenciais e segredos. Atualize os Secrets e reinicie os Pods que os utilizam para aplicar as alterações."
        validation:
          - command: "kubectl get secret db-credentials -o jsonpath='{.data.username}' | base64 --decode | grep -q dbuser && echo 'ok'"
            expectedOutput: "ok"
            errorMessage: "O Secret db-credentials não foi criado corretamente"
          - command: "kubectl get secret api-token -o jsonpath='{.data.token}' | base64 --decode | grep -q 'admin-token-value' && echo 'ok'"
            expectedOutput: "ok"
            errorMessage: "O Secret api-token não foi criado corretamente"

      - name: "Utilizando Secrets em Pods"
        description: "Aprenda a injetar dados sensíveis em aplicações usando Secrets"
        steps:
          - "**Métodos de Uso de Secrets em Pods**"
          - "Assim como os ConfigMaps, os Secrets podem ser utilizados nos Pods de três maneiras principais:"
          - "1. Como variáveis de ambiente"
          - "2. Como arquivos montados em um volume"
          - "3. Para autenticação em registros de imagens"
          - "**1. Usando Secrets como Variáveis de Ambiente**"
          - "Crie um Pod que usa valores do Secret como variáveis de ambiente:"
          - "`vi pod-secret-env.yaml`"
          - "```yaml"
          - "apiVersion: v1"
          - "kind: Pod"
          - "metadata:"
          - "  name: secret-env-pod"
          - "spec:"
          - "  containers:"
          - "  - name: app-container"
          - "    image: busybox"
          - "    command: ['sh', '-c', 'echo Database User: $DB_USERNAME && sleep 3600']"
          - "    env:"
          - "    - name: DB_USERNAME"
          - "      valueFrom:"
          - "        secretKeyRef:"
          - "          name: db-credentials"
          - "          key: username"
          - "    - name: DB_PASSWORD"
          - "      valueFrom:"
          - "        secretKeyRef:"
          - "          name: db-credentials"
          - "          key: password"
          - "```"
          - "Aplique o arquivo YAML:"
          - "`kubectl apply -f pod-secret-env.yaml`"
          - "Verifique se o Pod está usando o Secret:"
          - "`kubectl logs secret-env-pod`"
          - "**2. Montando Secrets como Volumes**"
          - "Crie um Pod que monta um Secret como um volume:"
          - "`vi pod-secret-volume.yaml`"
          - "```yaml"
          - "apiVersion: v1"
          - "kind: Pod"
          - "metadata:"
          - "  name: secret-volume-pod"
          - "spec:"
          - "  containers:"
          - "  - name: app-container"
          - "    image: busybox"
          - "    command: ['sh', '-c', 'ls -la /etc/credentials && echo Token: $(cat /etc/credentials/token) && sleep 3600']"
          - "    volumeMounts:"
          - "    - name: secret-volume"
          - "      mountPath: /etc/credentials"
          - "      readOnly: true"
          - "  volumes:"
          - "  - name: secret-volume"
          - "    secret:"
          - "      secretName: api-token"
          - "```"
          - "Aplique o arquivo YAML:"
          - "`kubectl apply -f pod-secret-volume.yaml`"
          - "Verifique os logs do Pod:"
          - "`kubectl logs secret-volume-pod`"
          - "**3. Usando Secrets para Autenticação em Registros de Imagens**"
          - "Para criar um Secret para autenticação em um registro Docker:"
          - "`kubectl create secret docker-registry registry-credentials --docker-server=https://index.docker.io/v1/ --docker-username=your-username --docker-password=your-password --docker-email=your-email@example.com`"
          - "Crie um Pod que usa esse Secret para pull de imagens:"
          - "`vi pod-registry-secret.yaml`"
          - "```yaml"
          - "apiVersion: v1"
          - "kind: Pod"
          - "metadata:"
          - "  name: private-image-pod"
          - "spec:"
          - "  containers:"
          - "  - name: private-container"
          - "    image: busybox"
          - "    command: ['sh', '-c', 'echo Hello from private image && sleep 3600']"
          - "  imagePullSecrets:"
          - "  - name: registry-credentials"
          - "```"
          - "Aplique o arquivo YAML:"
          - "`kubectl apply -f pod-registry-secret.yaml`"
          - "**Atualizando Secrets**"
          - "Para atualizar um Secret existente:"
          - "`kubectl create secret generic db-credentials --from-literal=username=newuser --from-literal=password=NewP@ss! --dry-run=client -o yaml | kubectl apply -f -`"
          - "Os Pods que usam o Secret como variáveis de ambiente precisarão ser reiniciados para usar os novos valores:"
          - "`kubectl delete pod secret-env-pod`"
          - "`kubectl apply -f pod-secret-env.yaml`"
          - "No entanto, os Pods que montam o Secret como volume verão as atualizações automaticamente em alguns minutos (geralmente em até 60 segundos)."
        tips:
          - type: "warning"
            title: "Visibilidade de Secrets"
            content: "Os valores dos Secrets são visíveis em texto claro dentro dos containers. Qualquer processo com acesso ao container pode ler esses valores. Limitar o acesso aos Pods é essencial."
          - type: "info"
            title: "Gerenciadores de Secrets Externos"
            content: "Para ambientes de produção, considere soluções como Vault, AWS Secrets Manager ou GCP Secret Manager integrados ao Kubernetes usando operadores específicos."
          - type: "tip"
            title: "Validação de Secrets"
            content: "Implemente validações em seus aplicativos para verificar se os Secrets necessários estão presentes e válidos antes de iniciar operações críticas."
        validation:
          - command: "kubectl logs secret-env-pod | grep -q 'Database User: dbuser' && echo 'ok'"
            expectedOutput: "ok"
            errorMessage: "O Pod secret-env-pod não está usando corretamente as variáveis de ambiente do Secret"
          - command: "kubectl logs secret-volume-pod | grep -q 'Token:' && echo 'ok'"
            expectedOutput: "ok"
            errorMessage: "O Pod secret-volume-pod não está montando corretamente o Secret como volume"

      - name: "Casos de Uso e Boas Práticas"
        description: "Entenda cenários comuns e boas práticas para uso efetivo de ConfigMaps e Secrets"
        steps:
          - "**Caso de Uso 1: Aplicação Multi-ambiente**"
          - "Um padrão comum é ter diferentes configurações para ambientes de desenvolvimento, homologação e produção. ConfigMaps permitem manter a mesma imagem de container com configurações específicas para cada ambiente."
          - "Vamos criar ConfigMaps para diferentes ambientes:"
          - "`kubectl create namespace dev`"
          - "`kubectl create namespace prod`"
          - "`kubectl create configmap app-config -n dev --from-literal=API_URL=api-dev.example.com --from-literal=LOG_LEVEL=debug`"
          - "`kubectl create configmap app-config -n prod --from-literal=API_URL=api.example.com --from-literal=LOG_LEVEL=info`"
          - "Verifique as diferenças:"
          - "`kubectl get configmap app-config -n dev -o yaml`"
          - "`kubectl get configmap app-config -n prod -o yaml`"
          - "**Caso de Uso 2: Injeção de Arquivos de Configuração**"
          - "Muitas aplicações usam arquivos de configuração complexos (JSON, YAML, XML, etc.)."
          - "Crie um arquivo de configuração em JSON:"
          - "`vi app-config.json`"
          - "```json"
          - "{"
          - "  \"database\": {"
          - "    \"host\": \"db.example.com\","
          - "    \"port\": 3306,"
          - "    \"maxConnections\": 100"
          - "  },"
          - "  \"cache\": {"
          - "    \"enabled\": true,"
          - "    \"ttl\": 300"
          - "  },"
          - "  \"features\": {"
          - "    \"newUI\": false,"
          - "    \"analytics\": true"
          - "  }"
          - "}"
          - "```"
          - "Crie um ConfigMap a partir desse arquivo JSON:"
          - "`kubectl create configmap json-config --from-file=config.json=app-config.json`"
          - "Verifique o ConfigMap:"
          - "`kubectl get configmap json-config -o yaml`"
          - "**Caso de Uso 3: Certificados TLS em Secrets**"
          - "Para aplicações que exigem TLS/SSL, os certificados e chaves privadas podem ser armazenados como Secrets."
          - "Gere um certificado autoassinado para demonstração:"
          - "`openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout tls.key -out tls.crt -subj \"/CN=example.com\"`"
          - "Crie um Secret do tipo TLS:"
          - "`kubectl create secret tls example-tls --cert=tls.crt --key=tls.key`"
          - "Verifique o Secret criado:"
          - "`kubectl describe secret example-tls`"
          - "**Boas Práticas para ConfigMaps e Secrets**"
          - "1. **Separação de Responsabilidades**: Mantenha configurações e segredos separados (ConfigMaps para configurações não sensíveis, Secrets para dados sensíveis)"
          - "2. **Granularidade Apropriada**: Não crie um único ConfigMap ou Secret gigante; divida-os logicamente"
          - "3. **Versionamento**: Inclua versões nas configurações para facilitar rollbacks e rastreabilidade"
          - "4. **Validação**: Valide a sintaxe das configurações antes de aplicá-las"
          - "5. **Monitoramento**: Configure alertas para alterações em ConfigMaps e Secrets críticos"
          - "6. **Ciclo de Vida**: Defina processos claros para criação, atualização e remoção de configurações"
          - "7. **Documentação**: Mantenha documentação atualizada sobre o propósito e os valores esperados para cada configuração"
          - "**Limitações e Considerações**"
          - "- ConfigMaps e Secrets têm limite de tamanho de 1MB"
          - "- Secrets são codificados em base64, mas não são criptografados por padrão"
          - "- A atualização de valores em Pods existentes não é automática para variáveis de ambiente"
          - "- Em grandes clusters, muitos ConfigMaps e Secrets podem impactar o desempenho do etcd"
        tips:
          - type: "info"
            title: "Ferramentas Adicionais"
            content: "Para gerenciamento avançado de configurações, considere ferramentas como Kustomize, Helm ou Operators para gerenciar ConfigMaps e Secrets de forma declarativa."
          - type: "warning"
            title: "Vazamento de Dados Sensíveis"
            content: "Tenha cuidado com logs e dumps de debug que podem expor variáveis de ambiente contendo dados sensíveis. Configure suas aplicações para mascarar informações sensíveis nos logs."
          - type: "tip"
            title: "Escalabilidade"
            content: "Para conjuntos grandes de configurações, considere usar ConfigMaps apenas para ponteiros para uma fonte externa, como um servidor de configuração centralizado."
        validation:
          - command: "kubectl get configmap json-config -o jsonpath='{.data.config\\.json}' | grep -q database && echo 'ok'"
            expectedOutput: "ok"
            errorMessage: "O ConfigMap json-config não foi criado corretamente com o arquivo JSON"
          - command: "kubectl get secret example-tls -o jsonpath='{.type}' | grep -q 'kubernetes.io/tls' && echo 'ok'"
            expectedOutput: "ok"
            errorMessage: "O Secret TLS não foi criado corretamente"
