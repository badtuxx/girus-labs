apiVersion: v1
kind: ConfigMap
metadata:
  name: docker-fundamentos-redes-lab
  namespace: girus
  labels:
    app: girus-lab-template
data:
  lab.yaml: |
    name: docker-fundamentos-redes
    title: "Redes no Docker: Conceitos e Implementação"
    description: "Aprenda os fundamentos de redes no Docker, compreendendo os diferentes drivers de rede (bridge, host, none), os mecanismos de isolamento e comunicação entre containers, e como implementar redes personalizadas para aplicações multi-container. Este laboratório guiado explora conceitos práticos essenciais para criar arquiteturas de aplicações containerizadas eficientes e seguras."
    duration: 35m
    image: "linuxtips/girus-devops:0.1"
    privileged: true # Necessário para gerenciar redes Docker
    tasks:
      - name: "Fundamentos de Redes no Docker"
        description: "Compreenda a arquitetura de rede do Docker, os tipos de drivers disponíveis e como o Docker gerencia a comunicação entre containers e com o mundo externo."
        steps:
          - "**Arquitetura de Redes no Docker**"
          - "O Docker implementa um sistema de redes sofisticado que permite diferentes níveis de isolamento e conectividade entre containers. Esta arquitetura é baseada em **drivers de rede** que fornecem diferentes implementações para casos de uso específicos."
          - "**Os quatro componentes principais da rede Docker são:**"
          - "1. **Container Network Model (CNM)**: O modelo conceitual que define a rede Docker"
          - "2. **Libnetwork**: A implementação real do CNM no Docker"
          - "3. **Drivers**: Plugins que implementam diferentes tipos de rede (bridge, host, overlay, etc.)"
          - "4. **IPAM Drivers**: Gerenciamento de endereços IP (alocação de IPs, subredes, etc.)"
          - "**Principais Drivers de Rede no Docker**"
          - "O Docker inclui vários drivers de rede por padrão, cada um com características específicas:"
          - "- **bridge**: O driver padrão, cria uma rede isolada no host (usa interfaces virtuais e iptables)"
          - "- **host**: Remove o isolamento de rede, o container usa diretamente a rede do host"
          - "- **none**: Desativa completamente a rede para o container"
          - "- **overlay**: Permite redes multi-host para comunicação entre containers em diferentes hosts"
          - "- **macvlan**: Atribui um endereço MAC ao container, fazendo-o aparecer como um dispositivo físico na rede"
          - "Vamos explorar os principais drivers neste laboratório, começando pelos drivers padrão."
          - "**Visualizando as Redes Disponíveis**"
          - "Para listar todas as redes disponíveis no Docker, use o comando:"
          - "`docker network ls`"
          - "A saída mostrará algo como:"
          - "```"
          - "NETWORK ID     NAME      DRIVER    SCOPE"
          - "xxxxxxxxxxxx   bridge    bridge    local"
          - "xxxxxxxxxxxx   host      host      local"
          - "xxxxxxxxxxxx   none      null      local"
          - "```"
          - "Podemos ver que Docker cria três redes por padrão: bridge (padrão), host e none."
          - "**Obtendo Informações Detalhadas Sobre Redes**"
          - "Para inspecionar uma rede específica e entender sua configuração detalhada:"
          - "`docker network inspect bridge`"
          - "Este comando mostrará um JSON com informações como:"
          - "- Configuração de rede (subnet, gateway)"
          - "- Driver utilizado"
          - "- Opções de configuração"
          - "- Containers conectados a esta rede (se houver)"
        tips:
          - type: "info"
            title: "Docker e Namespaces"
            content: "O Docker utiliza o conceito de Namespaces do Linux para isolamento de rede. Cada container tem seu próprio namespace de rede, o que permite que tenha suas próprias interfaces, tabelas de roteamento e regras de firewall."
          - type: "tip"
            title: "Inspecionando Recursos Docker"
            content: "O comando 'docker inspect' é extremamente útil para debug. Você pode usar formatadores para extrair informações específicas, como: 'docker network inspect -f \"{{.IPAM.Config}}\" bridge'"
          - type: "warning"
            title: "Modificando Redes Padrão"
            content: "Evite modificar as configurações das redes padrão do Docker. É melhor criar novas redes personalizadas para suas necessidades específicas."
        validation:
          - command: "docker network ls | grep -q bridge && echo 'ok'"
            expectedOutput: "ok"
            errorMessage: "A rede 'bridge' padrão não foi encontrada. Verifique a instalação do Docker."
          - command: "docker network ls | wc -l"
            expectedExpression: "> 3"
            errorMessage: "O Docker deve criar pelo menos 3 redes por padrão."

      - name: "Rede Bridge Padrão"
        description: "Explore o funcionamento da rede bridge padrão do Docker, compreendendo suas características, limitações e casos de uso."
        steps:
          - "**Rede Bridge Padrão: Conceito e Funcionamento**"
          - "A rede 'bridge' é o driver padrão usado pelo Docker quando você não especifica uma rede. Ela cria uma rede privada interna no host onde os containers podem se comunicar entre si, enquanto mantém isolamento do resto do mundo."
          - "Tecnicamente, o Docker cria uma interface de bridge virtual chamada 'docker0' no host, à qual os containers se conectam através de interfaces virtuais pareadas (veth pairs)."
          - "Vamos explorar esta rede em detalhes:"
          - "`docker network inspect bridge`"
          - "Observe na saída a subnet utilizada (geralmente 172.17.0.0/16) e o gateway (geralmente 172.17.0.1), que corresponde à interface docker0 no host."
          - "**Executando Containers na Rede Bridge**"
          - "Quando você executa um container sem especificar uma rede, ele é conectado à rede bridge padrão e recebe um IP desta subnet:"
          - "`docker run --rm alpine ip addr show eth0`"
          - "Você verá que o container recebe um endereço IP da subnet da bridge (geralmente algo como 172.17.0.x)."
          - "**Testando Conectividade na Rede Bridge**"
          - "Vamos executar dois containers Nginx em background para testar a conectividade entre eles:"
          - "`docker run -d --name web1 nginx:alpine`"
          - "`docker run -d --name web2 nginx:alpine`"
          - "Agora, vamos tentar pingar 'web2' a partir de 'web1' usando o nome:"
          - "`docker exec web1 ping -c 2 web2 || echo 'Ping falhou ou nome não resolvido'`"
          - "**Este comando provavelmente falhará.** Isso ocorre porque a rede bridge padrão **não oferece resolução de nomes automática** entre containers. Cada container pode ver apenas seu próprio nome de host."
          - "Porém, a comunicação por IP funciona perfeitamente. Vamos obter o IP de 'web2' e tentar novamente:"
          - "`IP_WEB2=$(docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' web2)`"
          - "`echo \"O IP do container web2 é: $IP_WEB2\"`"
          - "`docker exec web1 ping -c 2 $IP_WEB2`"
          - "Esta comunicação deve ser bem-sucedida, demonstrando que os containers na rede bridge padrão podem se comunicar via IP, mas não por nome."
          - "**Publicando Portas na Rede Bridge**"
          - "Para que serviços dentro dos containers sejam acessíveis do host ou de fora, é necessário publicar portas usando o parâmetro `-p` ou `--publish`:"
          - "`docker stop web1`"
          - "`docker run -d --name web1 -p 8080:80 nginx:alpine`"
          - "Este comando mapeia a porta 8080 do host para a porta 80 do container. Agora, você pode acessar o Nginx do container através do host:"
          - "`curl localhost:8080`"
          - "Internamente, o Docker configura regras de NAT (DNAT) no iptables para redirecionar o tráfego da porta 8080 do host para a porta 80 do container."
          - "**Limpeza**"
          - "Vamos remover os containers antes de prosseguir:"
          - "`docker stop web1 web2 && docker rm web1 web2`"
        tips:
          - type: "info"
            title: "Rede Bridge Padrão"
            content: "A rede 'bridge' padrão isola os containers do mundo externo, mas permite comunicação entre eles por IP. A resolução de nomes entre containers não é habilitada por padrão nesta rede, sendo esta uma de suas principais limitações."
          - type: "warning"
            title: "Limitações de Segurança"
            content: "Todos os containers na bridge padrão compartilham a mesma rede, podendo haver falta de isolamento adequado para aplicações críticas. Para melhor isolamento, considere usar redes bridge personalizadas."
          - type: "tip"
            title: "Publicação de Portas"
            content: "Ao publicar portas com '-p', você pode especificar interfaces específicas, como '-p 127.0.0.1:8080:80' para permitir acesso apenas do localhost, aumentando a segurança."
        validation:
          - command: "docker network inspect bridge -f '{{.Driver}}'"
            expectedOutput: "bridge"
            errorMessage: "A rede padrão 'bridge' não foi encontrada ou não é do tipo bridge."
          - command: "ip addr show docker0 2>/dev/null | grep -q 'inet' && echo 'ok' || echo 'Sem interface docker0'"
            expectedOutput: "ok"
            errorMessage: "A interface docker0 não foi encontrada no host. Verifique a configuração do Docker."

      - name: "Rede Host"
        description: "Explore o driver de rede 'host', entendendo suas implicações de desempenho e segurança, e quando é apropriado utilizá-lo."
        steps:
          - "**O Driver de Rede 'host': Eliminando o Isolamento**"
          - "O driver de rede 'host' remove completamente o isolamento de rede entre o container e o host. Em vez de criar um namespace de rede separado, o container usa diretamente o namespace de rede do host."
          - "Isso significa que o container:"
          - "- Compartilha a pilha de rede, interfaces e endereços IP com o host"
          - "- Tem acesso direto a todos os serviços de rede do host"
          - "- Não requer mapeamento de portas (publicação de portas é ignorada e desnecessária)"
          - "**Quando usar a rede 'host'?**"
          - "A rede host é útil principalmente em dois cenários:"
          - "1. **Performance**: Elimina a sobrecarga do NAT e das bridges virtuais, oferecendo desempenho de rede nativo"
          - "2. **Acesso a interfaces específicas**: Quando o container precisa acessar diretamente interfaces de rede específicas do host"
          - "**Testando a Rede Host**"
          - "Vamos visualizar o efeito da rede host executando um container Alpine e comparando suas interfaces de rede com as do host:"
          - "`docker run --rm --network host alpine ifconfig`"
          - "Compare a saída acima com as interfaces de rede do próprio host:"
          - "`ifconfig`"
          - "Observe que as saídas são idênticas ou muito semelhantes, indicando que o container está usando diretamente as interfaces de rede do host."
          - "**Demonstração Prática: Servidor Web na Rede Host**"
          - "Vamos executar um servidor Nginx na rede host:"
          - "`docker run -d --name nginx-host --network host nginx:alpine`"
          - "Note que não precisamos especificar o mapeamento de portas com `-p`. O Nginx estará disponível diretamente na porta 80 do host (desde que nada mais esteja usando esta porta):"
          - "`curl localhost:80`"
          - "Se o comando acima retornar a página HTML do Nginx, significa que o servidor está acessível diretamente através da rede do host."
          - "**Conflitos de Porta na Rede Host**"
          - "Um aspecto importante a considerar com a rede host é o potencial para conflitos de porta. Vamos demonstrar isso tentando executar dois servidores Nginx na rede host:"
          - "`docker run -d --name nginx-host2 --network host nginx:alpine`"
          - "Este comando provavelmente falhará ou causará problemas, pois o segundo container tentará utilizar a mesma porta 80 que já está em uso pelo primeiro container."
          - "**Limpeza**"
          - "`docker stop nginx-host nginx-host2 2>/dev/null || true`"
          - "`docker rm nginx-host nginx-host2 2>/dev/null || true`"
        tips:
          - type: "warning"
            title: "Riscos da Rede Host"
            content: "Usar `--network host` remove o isolamento de rede, o que representa um risco significativo de segurança. O container pode acessar qualquer serviço rodando no host e pode haver conflitos de porta. Use com cautela, especialmente em ambientes de produção."
          - type: "info"
            title: "Performance vs Segurança"
            content: "A rede host oferece melhor desempenho por eliminar a camada de virtualização de rede, mas ao custo de segurança e isolamento. Avalie este trade-off com base nos requisitos da sua aplicação."
          - type: "tip"
            title: "Monitoramento de Rede"
            content: "Containers que precisam monitorar o tráfego de rede do host (como ferramentas de IDS/IPS) geralmente se beneficiam da rede host, pois podem ver todo o tráfego passando pelas interfaces físicas."
        validation:
          - command: "docker run --rm --network host alpine hostname"
            expectedOutput: "`hostname`" # Captura o hostname real do host onde o lab roda
            errorMessage: "O container executado com --network host não parece estar compartilhando o hostname do host."
          - command: "docker run --rm --network host alpine ip addr | grep -q docker0 && echo 'Interfaces do host visíveis' || echo 'Interfaces do host não visíveis'"
            expectedOutput: "Interfaces do host visíveis"
            errorMessage: "O container com rede host não parece estar visualizando as interfaces do host corretamente."

      - name: "Rede Bridge Customizada"
        description: "Aprenda a criar e utilizar redes bridge personalizadas para obter melhor isolamento, resolução de nomes automática e controle mais granular sobre a comunicação entre containers."
        steps:
          - "**Redes Personalizadas: Superando as Limitações da Bridge Padrão**"
          - "As redes bridge personalizadas resolvem várias limitações da rede bridge padrão, oferecendo:"
          - "- **Resolução de nomes automática**: Containers podem se comunicar usando nomes, não apenas IPs"
          - "- **Melhor isolamento**: Containers em redes diferentes não podem se comunicar diretamente"
          - "- **Configuração mais flexível**: Opções para configurar IPAM, MTU, etc."
          - "- **Melhor segurança**: Isolamento mais preciso entre grupos de containers"
          - "**Criando uma Rede Bridge Personalizada**"
          - "Para criar uma nova rede bridge, usamos o comando `docker network create`:"
          - "`docker network create minha-rede`"
          - "O comando acima cria uma rede bridge básica com configurações padrão. Para configurações mais avançadas, podemos especificar parâmetros adicionais:"
          - "`docker network create --driver bridge --subnet=192.168.10.0/24 --gateway=192.168.10.1 minha-rede-customizada`"
          - "**Inspecionando a Nova Rede**"
          - "Vamos examinar a rede que acabamos de criar:"
          - "`docker network inspect minha-rede`"
          - "Observe na saída o driver utilizado (bridge), a subnet atribuída e outras configurações. Neste momento, não há containers conectados à rede."
          - "**Conectando Containers à Rede Personalizada**"
          - "Vamos executar dois containers Nginx e conectá-los à nossa rede personalizada:"
          - "`docker run -d --name web-net1 --network minha-rede nginx:alpine`"
          - "`docker run -d --name web-net2 --network minha-rede nginx:alpine`"
          - "**Testando a Resolução de Nomes**"
          - "Agora, vamos testar a resolução de nomes entre os containers na rede personalizada:"
          - "`docker exec web-net1 ping -c 2 web-net2`"
          - "Observe que, diferentemente da rede bridge padrão, a comunicação por nome funciona automaticamente! Isso acontece porque Docker implementa um servidor DNS embutido para as redes personalizadas."
          - "**Conectando Containers a Múltiplas Redes**"
          - "Containers também podem ser conectados a múltiplas redes para permitir comunicação controlada entre diferentes segmentos:"
          - "`docker network create rede-secundaria`"
          - "`docker run -d --name web-net3 --network rede-secundaria nginx:alpine`"
          - "`docker network connect minha-rede web-net3`"
          - "Agora o container 'web-net3' está conectado a ambas as redes e pode se comunicar com containers em qualquer uma delas:"
          - "`docker exec web-net3 ping -c 2 web-net1`  # Deve funcionar pois estão na mesma rede 'minha-rede'`"
          - "`docker exec web-net1 ping -c 2 web-net3`  # Também deve funcionar`"
          - "**Desconectando e Removendo Redes**"
          - "Podemos desconectar um container de uma rede:"
          - "`docker network disconnect minha-rede web-net3`"
          - "E quando terminamos, podemos limpar nossas redes e containers:"
          - "`docker stop web-net1 web-net2 web-net3`"
          - "`docker rm web-net1 web-net2 web-net3`"
          - "`docker network rm minha-rede rede-secundaria minha-rede-customizada 2>/dev/null || true`"
        tips:
          - type: "tip"
            title: "Vantagens de Redes Customizadas"
            content: "Redes bridge customizadas são a melhor prática para aplicações Docker. Elas fornecem melhor isolamento e resolução DNS automática entre os containers conectados a ela, facilitando a criação de aplicações multi-container."
          - type: "info"
            title: "Controle de Comunicação"
            content: "Use múltiplas redes para criar 'segmentos' lógicos e controlar precisamente quais containers podem se comunicar entre si, implementando um modelo de segurança em camadas."
          - type: "warning"
            title: "Planejamento de Subnets"
            content: "Ao definir manualmente subnets para suas redes Docker personalizadas, certifique-se de que elas não se sobreponham a outras redes na sua infraestrutura, evitando problemas de roteamento."
        validation:
          - command: "docker network create test-net && docker network rm test-net && echo 'ok' || echo 'falha'"
            expectedOutput: "ok"
            errorMessage: "Não foi possível criar e remover uma rede de teste. Verifique as permissões do Docker."
          - command: "docker network ls -f name=minha-rede --format '{{.Name}}' 2>/dev/null || echo 'removed'" # Verifica se foi removida na limpeza
            expectedOutput: "removed"
            errorMessage: "A rede customizada 'minha-rede' não foi removida corretamente."

      - name: "Análise Avançada de Redes Docker"
        description: "Aprenda a inspecionar e diagnosticar redes Docker no nível do sistema operacional, compreendendo a implementação subjacente de bridges, interfaces e regras de roteamento."
        steps:
          - "**Visão Interna da Implementação de Redes Docker**"
          - "Para entender completamente como o Docker implementa suas redes, vamos examinar as interfaces e configurações criadas no nível do sistema operacional."
          - "**Examinando Bridges Virtuais**"
          - "Cada rede bridge do Docker cria uma bridge virtual Linux. Vamos ver todas as bridges no sistema:"
          - "`ip link show type bridge`"
          - "Você deve ver a bridge padrão 'docker0' e possivelmente outras bridges para as redes personalizadas que criamos."
          - "Para ver as configurações de IP dessas bridges:"
          - "`ip addr show type bridge`"
          - "**Interfaces de Container (veth pairs)**"
          - "O Docker conecta containers às bridges usando pares de interfaces virtuais Ethernet (veth pairs). Um lado do par está dentro do namespace de rede do container (geralmente eth0), e o outro está conectado à bridge no namespace do host."
          - "Para ver todas as interfaces veth no host:"
          - "`ip link show type veth`"
          - "**Relacionamento container-veth**"
          - "Vamos criar um container e examinar sua interface de rede:"
          - "`docker run -d --name container-teste nginx:alpine`"
          - "`docker exec container-teste ip link show eth0`"
          - "Agora vamos encontrar o par correspondente no host. Primeiro, precisamos do ID do namespace de rede do container:"
          - "`NETNS=$(docker inspect -f '{{.NetworkSettings.SandboxKey}}' container-teste)`"
          - "`echo \"Namespace de rede: $NETNS\"`"
          - "Podemos ver todas as interfaces veth e seu namespace de destino (peer):"
          - "`ip link show type veth | grep -A1 veth`"
          - "**Regras de NAT (iptables)**"
          - "O Docker configura regras de NAT para permitir que containers na rede bridge acessem a rede externa e para implementar a publicação de portas:"
          - "`sudo iptables -t nat -L -n | grep -E 'MASQUERADE|DNAT'`"
          - "**Limpeza**"
          - "`docker stop container-teste && docker rm container-teste`"
        tips:
          - type: "info"
            title: "Ferramentas de Diagnóstico"
            content: "Para problemas complexos de rede Docker, ferramentas como tcpdump, nsenter e netshoot (container de diagnóstico de rede) podem ser extremamente úteis para analisar o tráfego e a configuração de rede."
          - type: "warning"
            title: "Modificando Interfaces Manualmente"
            content: "Tenha extremo cuidado ao modificar manualmente interfaces ou regras relacionadas ao Docker. O daemon do Docker pode sobrescrever suas alterações ou se comportar de maneira inesperada."
          - type: "tip"
            title: "Persistência de Configuração"
            content: "Para tornar as configurações de rede Docker persistentes, defina-as no arquivo daemon.json em vez de criar manualmente redes após cada reinicialização do Docker."
        validation:
          - command: "ip link show docker0 2>/dev/null | grep -q 'UP' && echo 'docker0 ativa' || echo 'docker0 inativa ou não encontrada'"
            expectedOutput: "docker0 ativa"
            errorMessage: "A interface bridge docker0 não está ativa ou não foi encontrada."
          - command: "ip addr show type bridge 2>/dev/null | grep -q 'inet' && echo 'Bridge com IP configurado' || echo 'Bridge sem IP'"
            expectedOutput: "Bridge com IP configurado"
            errorMessage: "As bridges Docker não parecem ter endereços IP configurados."
